<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>
Sites Tree
</TITLE>
</HEAD>
<BODY>
<H1>дерево сайтов </H1>
<p>
Дерево сайтов - это внутреннее представление ZAP сайтов, к которым вы получаете доступ, оно отображается на вкладке <a href="../../ui/tabs/sites.html"> Сайты </a>. 
Если он неточно отражает сайты, ZAP не сможет эффективно атаковать их. 
Каждый узел в дереве представляет отдельную функциональность на сайте.  
По умолчанию ZAP создает уникальные узлы в дереве на основе метода HTTP и имен параметров. 
</p>
<p>
Это означает, что все следующие запросы будут иметь разные узлы дерева: 
<ul>
<li>GET https://www.example.com/ex1?a=b&amp;c=d</li>
<li>GET https://www.example.com/ex1?a=b&amp;d=c</li>
<li>POST https://www.example.com/ex1?a=b&amp;c=d</li>
</ul>

И следующие запросы будут иметь один и тот же узел: 
<ul>
<li>GET https://www.example.com?a=b&amp;c=d</li>
<li>GET https://www.example.com?a=c&amp;c=c</li>
<li>GET https://www.example.com?a=e&amp;c=f</li>
</ul>

Это работает очень хорошо во многих случаях - разные методы HTTP и имена параметров обычно означают разные действия, в то время как значения параметров обычно не меняют результат. 

<H2>Исключения</H2>

Всегда есть исключения. 

<H3>Структурные параметры </H3>

Возьмем случай, когда действие, которое нужно предпринять, фактически определено в значении параметра: 
<ul>
<li>GET https://www.example.com?a=b&amp;action=add</li>
<li>GET https://www.example.com?a=b&amp;action=delete</li>
</ul>

В этом случае оба URL-адреса попадут в один и тот же узел дерева сайтов, что означает, что на практике будет атакован только один из них.  
Другой URL-адрес не будет атакован, и поэтому никакие уязвимости, относящиеся к этому действию, не будут обнаружены. 
<p>
В ZAP решение этой проблемы состоит в том, чтобы определить параметр «действие» как <a href="structparams.html"> структурный параметр </a>,
другими словами, параметр, значение которого фактически влияет на структуру сайта.  
Как только вы это сделаете (и повторно посетите URL-адреса), они появятся как 2 разных узла, и ZAP будет атаковать их по отдельности. 

<H3>Узлы, управляемые данными </H3>

И наоборот, у нас есть случай, когда элемент пути URL фактически является частью данных, а не частью структуры сайта.  
Например, следующие URL-адреса могут представлять одну и ту же функциональность, если второй элемент пути (companyX) на самом деле является данными: 

<ul>
<li>ttps://www.example.com/app/company1/aaa?ddd=eee</li>
<li>https://www.example.com/app/company2/aaa?ddd=fff</li>
<li>https://www.example.com/app/company3/aaa?ddd=ggg</li>
</ul>

В этом случае все 3 URL-адреса окажутся в уникальных узлах, и ZAP атакует каждый из них, даже если в этом нет необходимости.  
Вероятно, это не большая проблема, если имеется всего 3 экземпляра, но в большинстве случаев эти данные будут поступать из базы данных, поэтому таких узлов может быть огромное количество. 
<p>
Решением для этого является определение соответствующего элемента пути как <a href="ddc.html"> Содержимое, управляемое данными </a>, что означает элементы пути, которые действительно содержат данные, а не представляют часть структуры сайта. 
После того, как вы это сделаете (и повторно посетите URL-адреса), все они будут представлены как всего лишь 1 узел, и ZAP атакует их только один раз. 
<p>
Вам нужно будет определить как структурные параметры, так и узлы, управляемые данными вручную - ZAP в настоящее время не имеет возможности автоматически обнаруживать такие ситуации. 

<H3>Настраиваемые параметры </H3>

Наконец, есть случаи, когда сайты определяют специальные параметры, которые ZAP изначально не понимает.  
В результате ZAP может быть не в состоянии правильно разделить запросы на подходящие узлы. 
<p>
В этих случаях вы можете использовать Input Vector <a href="scripts.html"> Scripts </a>, который может представлять запрос в дереве сайтов любым удобным для вас способом. 

<h2>Node Name Format</h2>

<h3>Top Level Nodes</h3>
The top level node names include the protocol, host name and the port (if specified), e.g. <code>https://www.example.com:8080</code>

<h3>Intermediate Nodes</h3>
Non leaf nodes will just have the name of the relevant part of the URL path, unless they are configured to be 
<a href="ddc.html">Data Driven Content</a> in which case then will have the format <code>«ddc-name»</code>.

<h3>Leaf Nodes</h3>
Leaf node names are made up of:
<ul>
<li>The HTTP method (GET, POST, etc)
<li>A colon
<li>The last path element, or "/" if the last element is empty
<li>A list of the URL parameter names in round brackets
<li>An optional representation of the POST parameter names in round brackets
</ul>

A GET request to 
<ul>
<li><code>https://www.example.com/aaa/bbb?cc=dd&amp;ee=ff</code>
</ul>
will be represented as 3 nodes:
<ul>
<li>https://www.example.com
  <ul>
  <li>aaa
    <ul>
    <li>GET:bbb(cc,ee)
    </ul>
  </ul>
</ul>

A POST request to 
<ul>
<li><code>https://www.example.com/aaa/bbb/ccc/?cc=dd</code>
</ul>
 with "application/x-www-form-urlencoded" encoded data
<ul>
<li><code>cc=dd&amp;ee=ff&amp;gg=hh</code>
</ul>

will be represented as 5 nodes:
<ul>
<li>https://www.example.com
  <ul>
  <li>aaa
    <ul>
    <li>bbb
      <ul>
      <li>ccc
        <ul>
        <li>POST:/(cc)(cc,ee,gg)
        </ul>
      </ul>
    </ul>
  </ul>
</ul>

A POST request to 
<ul>
<li><code>https://www.example.com/aaa/bbb/ccc</code>
</ul>
with the JSON encoded data
<ul>
<li><code>{"aaa":{"bbb": "ccc", "ddd": "eee"}, fff: ["kkk", {"ggg":"hhh"}, {"iii":"jjj"}]}</code>
</ul>
will be represented as 4 nodes:
<ul>
<li>https://www.example.com
  <ul>
  <li>aaa
    <ul>
    <li>bbb
      <ul>
      <li>POST:ccc()({aaa:{bbb,ddd},fff:[{ggg},{iii}]})
      </ul>
    </ul>
  </ul>
</ul>

A POST request to 
<ul>
<li><code>https://www.example.com/aaa/bbb/</code>
</ul>
with the XML encoded data
<ul>
<li><code>&lt;aaa&gt;&lt;bbb&gt;BBB&lt;/bbb&gt;&lt;ccc&gt;CCC&lt;/ccc&gt;&lt;ddd&gt;DDD&lt;/ddd&gt;&lt;/aaa&gt;</code>
</ul>
will be represented as 4 nodes:
<ul>
<li>https://www.example.com
  <ul>
  <li>aaa
    <ul>
    <li>bbb
      <ul>
      <li>POST:/()(&lt;aaa:&lt;bbb&gt;,&lt;ccc&gt;,&lt;ddd&gt;&gt;)
      </ul>
    </ul>
  </ul>
</ul>

For JSON and XML data repeated child elements may be represented using "<code>..</code>".<br>
For example <ul>
<li><code>[{"a":{"b": "c", "d": "e"}},{"a":{"b": "f", "d": "g"}},{"a":{"b": "h", "d": "i"}}]</code>
</ul>
will be represented as 
<ul>
<li><code>[{a:{b,d}}..]</code>
</ul>
<p>
A POST request to 
<ul>
<li><code>https://www.example.com/aaa/</code>
</ul>
with multipart POST data like:
<pre>
-----------------------------3973496743964376987349857345
Content-Disposition: form-data; name="text"

text default
-----------------------------3973496743964376987349857345
Content-Disposition: form-data; name="file1"; filename="a.txt"
Content-Type: text/plain

Content of a.txt.

-----------------------------3973496743964376987349857345
Content-Disposition: form-data; name="file2"; filename="a.html"
Content-Type: text/html

&lt;!DOCTYPE html&gt;&lt;title&gt;Content of a.html.&lt;/title&gt;

-----------------------------3973496743964376987349857345--
</pre>

will be represented as 3 nodes:
<ul>
<li>https://www.example.com
  <ul>
  <li>aaa
    <ul>
    <li>POST:/()(multipart:text,file1,file2)
    </ul>
  </ul>
</ul>

<H2>Смотрите также</H2>
<table>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>
<a href="../../ui/overview.html">Обзор пользовательского интерфейса </a></td><td>обзор пользовательского интерфейса</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>
<a href="features.html">Функции </a></td><td>предоставлено ZAP </td></tr>
</table>

<H2>внешняя ссылка </H2>
<table>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><a href="https://www.zaproxy.org/blog/2020-09-22-sites-tree-modifiers/">Блог ZAP: модификаторы дерева сайтов </a></td></tr>
</table>

</BODY>
</HTML>
